# Лабораторная работа №9: "Сортировка и поиск"

**Выполнил:** Григорьев М.С.  
**Группа:** ИВТ-6  
**Вариант:** 3

## Постановка задачи

Разработать программу сортировки данных из файла с использованием метода двоичной вставки. Структура таблицы соответствует варианту №3.

**Требования к варианту:**
- Метод сортировки: 6. Метод двоичной вставки
- Тип ключа: строковый
- Длина ключа в байтах: 5
- Хранение данных и ключей: отдельно
- Минимальное число элементов таблицы: 13

## Описание алгоритма

### Метод двоичной вставки

Метод двоичной вставки является модификацией простой сортировки вставками. Основное отличие заключается в том, что при поиске позиции для вставки нового элемента используется бинарный (двоичный) поиск вместо линейного перебора.

**Алгоритм:**
1. Начиная со второго элемента, считаем, что все элементы до текущего уже отсортированы.
2. Для каждого элемента определяем позицию вставки в отсортированной части с помощью бинарного поиска.
3. Сдвигаем элементы отсортированной части, чтобы освободить место для вставки.
4. Вставляем текущий элемент на найденную позицию.

**Эффективность алгоритма:**
- Временная сложность: O(n²)
- Пространственная сложность: O(1)
- Количество сравнений: O(n log n)
- Количество перемещений: O(n²)

**Преимущество:**
Уменьшение количества сравнений по сравнению с обычной сортировкой вставками.

## Реализация программы

### Структура проекта
```
.
├── main.c          # Исходный код программы
├── main.h          # Заголовочный файл
├── output.txt      # Файл с отсортированными данными
└── tests/          # Директория с тестовыми данными
    ├── heart.txt
    ├── reverse.txt
    ├── straight.txt
    ├── poem.txt
    └── big.txt
```

### Структура данных

В соответствии с требованиями варианта, была реализована следующая структура для хранения данных:

```c
typedef struct {
    char keys[MAX_RECORDS][KEY_LENGTH + 1];  // Массив ключей
    char values[MAX_RECORDS][MAX_STRING_LENGTH];  // Массив значений
    int count;  // Количество записей
} Table;
```

Где:
- `MAX_RECORDS = 1000` - максимальное количество записей
- `KEY_LENGTH = 5` - длина ключа в байтах
- `MAX_STRING_LENGTH = 256` - максимальная длина значения

### Ключевые функции

#### Функция для чтения данных из файла
```c
int readData(const char *filename, Table *table) {
    FILE *file = fopen(filename, "r");
    if (!file) {
        printf("Ошибка открытия файла %s\n", filename);
        return 0;
    }
    
    int count = 0;
    char line[MAX_STRING_LENGTH * 2];
    
    while (count < MAX_RECORDS && fgets(line, sizeof(line), file)) {
        char *key = strtok(line, " \n");
        char *value = strtok(NULL, "\n");
        
        if (key && value) {
            if (strlen(key) > KEY_LENGTH) {
                printf("Ошибка: ключ '%s' длиннее %d знаков\n", key, KEY_LENGTH);
                fclose(file);
                return 0;
            }
            
            strncpy(table->keys[count], key, KEY_LENGTH);
            table->keys[count][KEY_LENGTH] = '\0';
            strcpy(table->values[count], value);
            count++;
        }
    }
    
    fclose(file);
    table->count = count;
    return count;
}
```

#### Функция для выполнения двоичного поиска позиции вставки
```c
int binarySearch(Table *table, int start, int end, const char *key) {
    if (end <= start) {
        comparison_count++;
        return (strcmp(key, table->keys[start]) > 0) ? (start + 1) : start;
    }
    
    int mid = (start + end) / 2;
    
    comparison_count++;
    if (strcmp(key, table->keys[mid]) == 0)
        return mid + 1;
    
    comparison_count++;
    if (strcmp(key, table->keys[mid]) > 0)
        return binarySearch(table, mid + 1, end, key);
    
    return binarySearch(table, start, mid - 1, key);
}
```

#### Метод двоичной вставки
```c
void binaryInsertionSort(Table *table) {
    comparison_count = 0;
    movement_count = 0;
    
    for (int i = 1; i < table->count; i++) {
        char key[KEY_LENGTH + 1];
        char value[MAX_STRING_LENGTH];
        strcpy(key, table->keys[i]);
        strcpy(value, table->values[i]);
        int j = i - 1;
        
        int location = binarySearch(table, 0, j, key);
        
        while (j >= location) {
            strcpy(table->keys[j + 1], table->keys[j]);
            strcpy(table->values[j + 1], table->values[j]);
            movement_count++;
            j--;
        }
        
        strcpy(table->keys[j + 1], key);
        strcpy(table->values[j + 1], value);
        movement_count++;
    }
}
```

## Дополнительные возможности программы

В программе реализованы следующие дополнительные возможности:
1. **Поиск по ключу** - возможность поиска записи по заданному ключу
2. **Настройка вывода** - возможность вывода ограниченного количества строк
3. **Статистика сортировки** - вывод информации о количестве сравнений и перемещений
4. **Тихий режим** - возможность отключить вывод таблицы в консоль

### Опции командной строки:

| Опция | Описание |
|-------|----------|
| `-s <ключ>` | Поиск записи по указанному ключу |
| `-t [N]` | Вывод последних N строк (по умолчанию 10) |
| `-i` | Вывод статистики сортировки |
| `-q` | Тихий режим (без вывода таблицы) |
| `-h` | Вывод справки |

## Тестирование программы

### Тестовые данные

Для тестирования программы были созданы следующие наборы данных:
1. **straight.txt** - упорядоченные данные (14 записей)
2. **reverse.txt** - обратно упорядоченные данные (13 записей)
3. **big.txt** - большой набор данных (101 запись)

### Пример входных данных (reverse.txt):
```
pear !
nut вставок
melon двоичных
lemon методом
kiwi сортировки
honey тестирования
grape начального
fig для
elder текста
date упорядоченного
cherr пример
berry как
apple Это
```

### Результаты тестирования

#### 1. Сортировка и статистика

Команда:
```bash
./sort_binary_insertion -i tests/reverse.txt
```

**Результат:**
```
Статистика сортировки:
Количество сравнений: 42
Количество перемещений: 53

Отсортированная таблица:

apple Это
berry как
cherr пример
date упорядоченного
elder текста
fig для
grape начального
honey тестирования
kiwi сортировки
lemon методом
melon двоичных
nut вставок
pear !
```

#### 2. Поиск по ключу

Команда:
```bash
./sort_binary_insertion -s lemon tests/reverse.txt
```

**Результат:**
```
Отсортированная таблица:

apple Это
berry как
cherr пример
date упорядоченного
elder текста
fig для
grape начального
honey тестирования
kiwi сортировки
lemon методом
melon двоичных
nut вставок
pear !

Поиск по ключу 'lemon': найдено на позиции 10, значение: методом
```

#### 3. Вывод ограниченного количества строк

Команда:
```bash
./sort_binary_insertion -t 5 tests/reverse.txt
```

**Результат:**
```
Отсортированная таблица:

kiwi сортировки
lemon методом
melon двоичных
nut вставок
pear !
```

## Анализ результатов

### Эффективность сортировки

Алгоритм двоичной вставки продемонстрировал хорошую эффективность при работе с различными наборами данных:

1. **Для упорядоченных данных**: требуется минимальное количество перемещений, так как элементы уже находятся в правильном порядке
2. **Для обратно упорядоченных данных**: требуется максимальное количество перемещений
3. **Для произвольных данных**: количество перемещений зависит от исходного порядка данных

За счет использования бинарного поиска удается значительно сократить количество сравнений по сравнению с обычной сортировкой вставками, особенно для больших массивов.

### Преимущества и ограничения

**Преимущества:**
- Эффективен при работе с малыми и средними объемами данных
- Требует меньше сравнений, чем обычная сортировка вставками
- Стабильный алгоритм сортировки (сохраняет относительный порядок равных элементов)

**Ограничения:**
- Хуже работает с большими объемами данных по сравнению с быстрой сортировкой или сортировкой слиянием
- Число перемещений остается O(n²), что ограничивает общую производительность

## Выводы

В ходе лабораторной работы была реализована программа сортировки данных методом двоичной вставки. Программа успешно выполняет сортировку строковых ключей с отдельным хранением значений, в соответствии с требованиями варианта.

Реализованный алгоритм двоичной вставки демонстрирует хорошую эффективность при работе с небольшими объемами данных. Использование бинарного поиска для определения позиции вставки значительно сокращает количество сравнений по сравнению с обычной сортировкой вставками, особенно для больших массивов.

Программа обладает дополнительными возможностями для удобства пользователя: поиск по ключу, настройка вывода, отображение статистики сортировки.

Все требования варианта задания полностью реализованы в программе:
- Реализован метод двоичной вставки
- Ключи имеют строковый тип и ограничены длиной 5 байт
- Данные и ключи хранятся отдельно
- Программа работает с таблицами, содержащими более 13 элементов 